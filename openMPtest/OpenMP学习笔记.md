# 2-27 Wednesday

## 多核时代如果仍用操作系统API创建线程的问题

### 1）CPU 核数扩展性问题 

多核编程需要考虑程序性能随 CPU 核数的扩展性，即硬件升级到更多核后，能够不修改程序就让程序性能增长，**这要求程序中创建的线程数量需要随 CPU 核数变化，不能创建固定数量的线程**，否则在 CPU 核数超过线程数量上的机器上运行，将无法完全利用机器性能。虽然通过一定方法可以使用操作系统 API 创建可变化数量的线程，但是比较麻烦，不如OpenMP 方便。 

### 2）方便性问题 

操作系统 API 创建线程时，需要线程入口函数，很难满足这个需求，除非将一个函数内的代码手工拆成多个线程入口函数，这将大大增加程序员的工作量。使用 OpenMP 创建线程则不需要入口函数，非常方便，可以将同一函数内的代码分解成多个线程执行，也可以将一个 for 循环分解成多个线程执行。 

### 3）可移植性问题 

目前各个主流操作系统的线程 API 互不兼容，缺乏事实上的统一规范，要满足可移植性得自己写一些代码，将各种不同操作系统的 api 封装成一套统一的接口。 OpenMP 是标准规范，所有支持它的编译器都是执行同一套标准，不存在可移植性问题 

## 基本概念

OpenMP是一种用于共享内存并行系统的多线程程序设计方案，支持的编程语言包括C、C++和Fortran。

OpenMP编程模型以线程为基础，通过编译制导指令制导并行化，有三种编程要素可以实现并行化控制，他们分别是编译制导、API函数集和环境变量。

## 执行模式

OpenMP采用 **fork-join** 的执行模式。

开始的时候只存在一个主线程，当需要进行并行计算的时候，派生出若干个分支线程来执行并行任务。当并行代码执行完成之后，分支线程会合，并把控制流程交给单独的主线程。

## 编译制导

编译制导指令以#pragma omp 开始，后边跟具体的功能指令



并行域内的变量可以通过子句说明为公有或私有，这对多线程程序的性能和正确性非常重要

通常循环变量、临时变量、写变量一般是私有的；
数组变量、仅用于读的变量通常是共享的。默认时为公有 

## C++中OpenMP使用

### 指令格式

pragma omp 指令 \[子句][子句]...]

### 常用指令

**parallel**，用在一个代码段之前，表示这段代码将被多个线程并行执行 

**for**，用于 for 循环之前，将循环分配到多个线程中并行执行，必须保证每次循环之间无相关性。 

**parallel for**， parallel 和 for 语句的结合，也是用在一个 for 循环之前，表示 for 循环的代码将被多个线程并行执行。
**sections**，用在可能会被并行执行的代码段之前
**parallel sections**， parallel 和 sections 两个语句的结合
**critical**，用在一段代码临界区之前
**single**，用在一段只被单个线程执行的代码段之前，表示后面的代码段将被单线程执行 

**barrier**，用于并行区内代码的线程同步，所有线程执行到 barrier 时要停止，直到所有线程都执行到 barrier 时才继续往下执行 